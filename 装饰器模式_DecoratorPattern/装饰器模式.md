# 装饰器模式

装饰器的核心就是再不改原有类的基础上给类新增功能。不改变原有类，可能有的小伙伴会想到继承、AOP切面，当然这些方式都可以实现，但是使用装饰器模式会是另外一种思路更为灵活，可以避免继承导致的子类过多，也可以避免AOP带来的复杂性。

动态地给对象添加一些额外的职责或者行为，装饰器模式相比于生成子类更为灵活。

https://juejin.cn/post/6844903681322647566#comment

## UML图





**角色：**

1.抽象构件角色（Component）-定义抽象接口
2.具体构件角色（ConcreteComponent）-实现抽象接口，可以是一组
3.装饰角色（Decorator）-定义抽象类并继承接口中的方法，保证一致性
4.具体装饰角色（ConcreteDecorator）-扩展装饰具体的实现逻辑





例如：

从多种维度去创建我们需要的产品。

手机是一个抽象的类（手机包含多种品牌），手机内存是一个抽象的类（有4G，8G，16G）。

（1）分离抽象和实现部分：把手机、内存抽象出来。实现与之分离。

（2）松耦合：两个维度分开

（3）单一职责原则：每个维度各干各的活

```java

//内存
public interface Memory {

    //安装内存
    public void addMemory();
}
public class Memory6G implements Memory{
    @Override
    public void addMemory() {
        System.out.println("手机安装了6G内存");
    }
}
public class Memory8G implements Memory{
    @Override
    public void addMemory() {
        System.out.println("手机安装了8G内存");
    }
}

public abstract class Phone {
    public Memory memory;
    //设置内存
    public void setMemory(Memory memory){
        this.memory = memory;
    }
    public abstract void byPhone();
}

public class XiaoMiPhone extends Phone{

    @Override
    public void byPhone() {
        memory.addMemory();
        System.out.println("购买小米手机");
    }
}

public class HuaWeiPhone extends Phone{

    @Override
    public void byPhone() {
        memory.addMemory();
        System.out.println("购买华为手机");
    }
}

 		public static void main(String[] args) {
        HuaWeiPhone huaWeiPhone = new HuaWeiPhone();
        //选择6g的手机
        huaWeiPhone.setMemory(new Memory6G());
        huaWeiPhone.byPhone();
    }
```

如果未来在有16G，32G的内存不需要改代码。





## 使用场景

- Java I/O 中的装饰者模式
- spring session 中的装饰者模式
- Mybatis 缓存中的装饰者模式

