# 责任链模式

享元模式（共享元数据模式）

运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似对象的开销，从而提高系统资源的利用率。



提到享元模式，就应该想到字符串的设计。一旦创建不会改变，创建的字符都放在字符串池中，需要就需要去串池中引用。



## UML图

![img](http://cdn.processon.com/5d1588f3e4b0a916e8f6da27?e=1561696004&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:7m9Cs8IifPd0WSfc0yG5XDGlOKo=)

**角色：**

- 抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。

- 具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请

  求，如果可以处理请求则处理，否则将该请求转给它的后继者。



代码：https://github.com/wangmyhome/DesignPatterns-Java

案例：请假审批

![image-20220111145715145](/Users/wangshanpeng/Library/Application Support/typora-user-images/image-20220111145715145.png)







**优点：**

降低了对象之间的耦合度

> 该模式降低了请求发送者和接收者的耦合度。

增强了系统的可扩展性

> 可以根据需要增加新的请求处理类，满足开闭原则。

增强了给对象指派职责的灵活性

> 当工作流程发生变化，可以动态地改变链内的成员或者修改它们的次序，也可动态地新增或者删除责任。

责任链简化了对象之间的连接

> 一个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。

责任分担：

> 每个类只需要处理自己该处理的工作，不能处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。

**缺点：**

> 不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。

> 对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。

> 职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。



这种模式好像弊大于利，尽量不用。

## 使用场景

- FilterChain是职责链（过滤器）模式

